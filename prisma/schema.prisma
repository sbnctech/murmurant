generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Enums

// ============================================================================
// GOVERNANCE SYSTEM ENUMS
// Minutes workflow state machine (Charter P3, P5)
// ============================================================================

enum GovernanceMeetingType {
  BOARD
  EXECUTIVE
  SPECIAL
  ANNUAL
}

// Minutes status state machine:
// DRAFT -> SUBMITTED -> (REVISED | APPROVED) -> PUBLISHED -> ARCHIVED
// Secretary edits DRAFT, submits to President
// President can return for REVISED or mark APPROVED
// Secretary publishes only if APPROVED
enum MinutesStatus {
  DRAFT // Secretary is editing
  SUBMITTED // Awaiting President review
  REVISED // President returned for changes
  APPROVED // President approved, ready to publish
  PUBLISHED // Published to board/members
  ARCHIVED // Historical record
}

enum MotionResult {
  PASSED
  FAILED
  TABLED
  WITHDRAWN
}

enum ReviewFlagType {
  INSURANCE_REVIEW
  LEGAL_REVIEW
  POLICY_REVIEW
  COMPLIANCE_CHECK
  GENERAL
}

enum ReviewFlagStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  DISMISSED
}

// Event note types for chair notebook
enum EventNoteType {
  PLANNING   // Pre-event planning notes
  VENUE      // Venue-specific info
  WRAP_UP    // Post-event summary
  LESSON     // Lessons learned for future
  HANDOFF    // Notes for next chair when cloning
}

// Registration lifecycle state machine (Charter P3)
// DRAFT -> PENDING_PAYMENT -> CONFIRMED -> (CANCELLED | REFUNDED | NO_SHOW)
enum RegistrationStatus {
  DRAFT // User started registration, no payment attempted
  PENDING_PAYMENT // Payment intent created, awaiting completion
  PENDING // Legacy: confirmed without payment (free events)
  CONFIRMED // Payment completed or free event confirmed
  WAITLISTED // On waitlist
  CANCELLED // User or admin cancelled
  REFUND_PENDING // Refund requested
  REFUNDED // Refund completed
  NO_SHOW // Did not attend
}

// Payment intent status (mirrors common payment processor states)
enum PaymentIntentStatus {
  CREATED
  PROCESSING
  SUCCEEDED
  FAILED
  CANCELLED
  REQUIRES_ACTION
  REFUND_PENDING
  REFUNDED
  PARTIALLY_REFUNDED
}

// Job Run Status for cron observability
enum JobRunStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED
  SKIPPED
}

enum EmailStatus {
  QUEUED
  SENT
  DELIVERED
  BOUNCED
  FAILED
}

// Service History Enums

enum ServiceType {
  BOARD_OFFICER
  COMMITTEE_CHAIR
  COMMITTEE_MEMBER
  EVENT_HOST
}

enum TransitionStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  APPLIED
  CANCELLED
}

// Event lifecycle state machine (Charter P3, P5)
// DRAFT -> PENDING_APPROVAL -> (CHANGES_REQUESTED | APPROVED) -> PUBLISHED -> COMPLETED
// CANCELED can be reached from any state except COMPLETED
// COMPLETED is derived when endTime < now (not a stored transition)
enum EventStatus {
  DRAFT              // Event chair is editing, not visible to members
  PENDING_APPROVAL   // Submitted for VP Activities review
  CHANGES_REQUESTED  // VP returned for revisions
  APPROVED           // VP approved, ready to publish
  PUBLISHED          // Visible to members, registrations open
  CANCELED           // Event cancelled (soft delete)
  COMPLETED          // Past event (derived from endTime < now)
}

// ============================================================================
// SUPPORT CASE SYSTEM ENUMS
// Tech Lead support intake workflow (see docs/operations/TECH_LEAD_SUPPORT_GUIDE.md)
// ============================================================================

// Support case status state machine:
// OPEN -> AWAITING_INFO -> OPEN -> IN_PROGRESS -> RESOLVED -> CLOSED
// Cases can also go directly OPEN -> CLOSED for trivial issues
enum SupportCaseStatus {
  OPEN           // New case, awaiting triage
  AWAITING_INFO  // Waiting for submitter to provide details
  IN_PROGRESS    // Being actively worked on
  ESCALATED      // Requires policy/governance decision
  RESOLVED       // Fix deployed or answer provided
  CLOSED         // Explicitly closed with rationale
}

// Issue category (initial guess, can be updated)
enum SupportCaseCategory {
  BUG                  // System behaving incorrectly
  UX_GAP               // Works, but confusing
  RULE_MISMATCH        // Policy vs implementation conflict
  MISSING_CAPABILITY   // Feature request
  EDUCATION            // Expectation mismatch, not a bug
  UNKNOWN              // Not yet categorized
}

// How the request came in
enum SupportCaseChannel {
  EMAIL
  TEXT
  SLACK
  IN_PERSON
  PHONE
  OTHER
}

// Resolution path chosen
enum SupportCaseResolution {
  RESPONSE_ONLY        // Education issue, low recurrence
  RESPONSE_PLUS_DOCS   // Documentation update needed
  RESPONSE_PLUS_FIX    // Code/rule change needed
  ESCALATED            // Policy decision required
  NO_ACTION_NEEDED     // Determined no action required
}

// Core Models

model Member {
  id                   String   @id @default(uuid()) @db.Uuid
  firstName            String
  lastName             String
  email                String   @unique
  phone                String?
  joinedAt             DateTime
  membershipStatusId   String   @db.Uuid
  membershipTierId     String?  @db.Uuid
  waMembershipLevelRaw String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  membershipStatus   MembershipStatus    @relation(fields: [membershipStatusId], references: [id])
  membershipTier     MembershipTier?     @relation(fields: [membershipTierId], references: [id])
  roleAssignments    RoleAssignment[]
  eventRegistrations EventRegistration[]
  userAccount        UserAccount?
  photos             Photo[]
  emailLogs          EmailLog[]
  events             Event[]

  // Service History relations
  serviceHistory               MemberServiceHistory[]
  serviceHistoryCreated        MemberServiceHistory[] @relation("ServiceHistoryCreatedBy")
  transitionAssignments        TransitionAssignment[]
  transitionsPresidentApproved TransitionPlan[]       @relation("TransitionPresidentApproval")
  transitionsVPApproved        TransitionPlan[]       @relation("TransitionVPApproval")
  transitionsApplied           TransitionPlan[]       @relation("TransitionAppliedBy")
  transitionsCreated           TransitionPlan[]       @relation("TransitionCreatedBy")

  // Publishing system relations
  pagesCreated     Page[]            @relation("PageCreatedBy")
  pagesUpdated     Page[]            @relation("PageUpdatedBy")
  permissions      Permission[]
  campaignsCreated MessageCampaign[]
  deliveryLogs     DeliveryLog[]
  auditLogs        AuditLog[]

  // Governance system relations
  meetingsCreated     GovernanceMeeting[]    @relation("MeetingCreatedBy")
  minutesCreated      GovernanceMinutes[]    @relation("MinutesCreatedBy")
  minutesLastEdited   GovernanceMinutes[]    @relation("MinutesLastEditedBy")
  minutesSubmitted    GovernanceMinutes[]    @relation("MinutesSubmittedBy")
  minutesReviewed     GovernanceMinutes[]    @relation("MinutesReviewedBy")
  minutesApproved     GovernanceMinutes[]    @relation("MinutesApprovedBy")
  minutesPublished    GovernanceMinutes[]    @relation("MinutesPublishedBy")
  motionsMoved        GovernanceMotion[]     @relation("MotionMovedBy")
  motionsSeconded     GovernanceMotion[]     @relation("MotionSecondedBy")
  motionsCreated      GovernanceMotion[]     @relation("MotionCreatedBy")
  annotationsCreated  GovernanceAnnotation[] @relation("AnnotationCreatedBy")
  reviewFlagsCreated  GovernanceReviewFlag[] @relation("FlagCreatedBy")
  reviewFlagsResolved GovernanceReviewFlag[] @relation("FlagResolvedBy")

  // Passkey administration relations
  passkeysRevoked PasskeyCredential[] @relation("PasskeyRevokedBy")
  // Session administration relations
  sessionsRevoked Session[]           @relation("SessionRevokedBy")
  // Impersonation relations (admin viewing as this member)
  sessionsImpersonating Session[]     @relation("SessionImpersonating")

  // Event approval workflow relations
  eventsSubmitted        Event[] @relation("EventSubmittedBy")
  eventsApproved         Event[] @relation("EventApprovedBy")
  eventsPublished        Event[] @relation("EventPublishedBy")
  eventsChangesRequested Event[] @relation("EventChangesRequestedBy")
  eventsCanceled         Event[] @relation("EventCanceledBy")
  eventNotes             EventNote[] @relation("EventNoteAuthor")

  // File system relations
  filesUploaded   FileObject[]   @relation("FileUploadedBy")
  fileAccessGrants FileAccess[]  @relation("FileAccessGrantedBy")

  // Event postmortem relations (Chair Notebook)
  postmortemsCreated  EventPostmortem[] @relation("PostmortemCreator")
  postmortemsApproved EventPostmortem[] @relation("PostmortemApprover")

  // Support case relations
  supportCasesSubmitted SupportCase[]     @relation
  supportCasesOwned     SupportCase[]     @relation("CaseOwner")
  supportCasesRelated   SupportCase[]     @relation("RelatedCases")
  supportCasesClosed    SupportCase[]     @relation("CaseCloser")
  supportCaseNotes      SupportCaseNote[]

  // Payment methods
  paymentMethods PaymentMethod[]

  @@index([membershipStatusId])
  @@index([membershipTierId])
}

model MembershipStatus {
  id                   String   @id @default(uuid()) @db.Uuid
  code                 String   @unique
  label                String
  description          String?
  isActive             Boolean  @default(true)
  isEligibleForRenewal Boolean  @default(false)
  isBoardEligible      Boolean  @default(false)
  sortOrder            Int      @default(0)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  members Member[]
}

model MembershipTier {
  id        String   @id @default(uuid()) @db.Uuid
  code      String   @unique
  name      String
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members Member[]

  @@index([sortOrder])
}

model Committee {
  id          String   @id @default(uuid()) @db.Uuid
  name        String
  slug        String   @unique
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  roleAssignments       RoleAssignment[]
  committeeRoles        CommitteeRole[]
  serviceHistory        MemberServiceHistory[]
  transitionAssignments TransitionAssignment[]
  events                Event[]

  @@index([isActive])
}

model CommitteeRole {
  id          String   @id @default(uuid()) @db.Uuid
  committeeId String   @db.Uuid
  name        String
  slug        String
  description String?
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  committee   Committee        @relation(fields: [committeeId], references: [id])
  assignments RoleAssignment[]

  @@unique([committeeId, slug])
  @@index([committeeId])
}

model Term {
  id        String   @id @default(uuid()) @db.Uuid
  name      String
  startDate DateTime
  endDate   DateTime
  isCurrent Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  roleAssignments RoleAssignment[]
  serviceHistory  MemberServiceHistory[]
  transitionPlans TransitionPlan[]
}

model RoleAssignment {
  id              String    @id @default(uuid()) @db.Uuid
  memberId        String    @db.Uuid
  committeeId     String    @db.Uuid
  committeeRoleId String    @db.Uuid
  termId          String    @db.Uuid
  startDate       DateTime
  endDate         DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  member        Member        @relation(fields: [memberId], references: [id])
  committee     Committee     @relation(fields: [committeeId], references: [id])
  committeeRole CommitteeRole @relation(fields: [committeeRoleId], references: [id])
  term          Term          @relation(fields: [termId], references: [id])

  @@index([memberId])
  @@index([committeeId])
  @@index([committeeRoleId])
  @@index([termId])
  @@index([termId, committeeId])
}

// Service History - Immutable records of member service
model MemberServiceHistory {
  id               String      @id @default(uuid()) @db.Uuid
  memberId         String      @db.Uuid
  serviceType      ServiceType
  roleTitle        String // Denormalized for immutability
  committeeId      String?     @db.Uuid
  committeeName    String? // Denormalized
  eventId          String?     @db.Uuid
  eventTitle       String? // Denormalized
  termId           String?     @db.Uuid
  termName         String? // Denormalized
  startAt          DateTime
  endAt            DateTime? // null = currently active
  transitionPlanId String?     @db.Uuid
  notes            String?
  createdAt        DateTime    @default(now())
  createdById      String?     @db.Uuid

  member         Member          @relation(fields: [memberId], references: [id])
  committee      Committee?      @relation(fields: [committeeId], references: [id])
  event          Event?          @relation(fields: [eventId], references: [id])
  term           Term?           @relation(fields: [termId], references: [id])
  transitionPlan TransitionPlan? @relation(fields: [transitionPlanId], references: [id])
  createdBy      Member?         @relation("ServiceHistoryCreatedBy", fields: [createdById], references: [id])

  // Reverse relation for TransitionAssignment.existingService
  transitionAssignments TransitionAssignment[]

  @@index([memberId])
  @@index([committeeId])
  @@index([eventId])
  @@index([termId])
  @@index([serviceType])
  @@index([startAt])
  @@index([endAt])
  @@index([memberId, endAt])
  @@index([transitionPlanId])
}

// Transition Plan - Scheduled leadership changes (Feb 1 / Aug 1)
model TransitionPlan {
  id                       String           @id @default(uuid()) @db.Uuid
  name                     String
  description              String?
  targetTermId             String           @db.Uuid
  effectiveAt              DateTime // Feb 1 or Aug 1 at midnight Pacific
  status                   TransitionStatus @default(DRAFT)
  presidentApprovedAt      DateTime?
  presidentApprovedById    String?          @db.Uuid
  vpActivitiesApprovedAt   DateTime?
  vpActivitiesApprovedById String?          @db.Uuid
  appliedAt                DateTime?
  appliedById              String?          @db.Uuid
  createdAt                DateTime         @default(now())
  updatedAt                DateTime         @updatedAt
  createdById              String?          @db.Uuid

  targetTerm             Term                   @relation(fields: [targetTermId], references: [id])
  presidentApprovedBy    Member?                @relation("TransitionPresidentApproval", fields: [presidentApprovedById], references: [id])
  vpActivitiesApprovedBy Member?                @relation("TransitionVPApproval", fields: [vpActivitiesApprovedById], references: [id])
  appliedBy              Member?                @relation("TransitionAppliedBy", fields: [appliedById], references: [id])
  createdBy              Member?                @relation("TransitionCreatedBy", fields: [createdById], references: [id])
  assignments            TransitionAssignment[]
  serviceHistory         MemberServiceHistory[]

  @@index([status])
  @@index([effectiveAt])
  @@index([targetTermId])
}

// Transition Assignment - Individual role changes in a plan
model TransitionAssignment {
  id                String      @id @default(uuid()) @db.Uuid
  transitionPlanId  String      @db.Uuid
  memberId          String      @db.Uuid
  serviceType       ServiceType
  roleTitle         String
  committeeId       String?     @db.Uuid
  isOutgoing        Boolean     @default(false)
  existingServiceId String?     @db.Uuid
  notes             String?
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  transitionPlan  TransitionPlan        @relation(fields: [transitionPlanId], references: [id], onDelete: Cascade)
  member          Member                @relation(fields: [memberId], references: [id])
  committee       Committee?            @relation(fields: [committeeId], references: [id])
  existingService MemberServiceHistory? @relation(fields: [existingServiceId], references: [id])

  @@index([transitionPlanId])
  @@index([memberId])
  @@index([committeeId])
}

model UserAccount {
  id           String    @id @default(uuid()) @db.Uuid
  memberId     String    @unique @db.Uuid
  email        String    @unique
  passwordHash String
  lastLoginAt  DateTime?
  isActive     Boolean   @default(true)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  member   Member              @relation(fields: [memberId], references: [id])
  passkeys PasskeyCredential[]
  sessions Session[]
}

// PasskeyCredential - WebAuthn/FIDO2 credentials for passwordless login
// Charter P1: Identity must be provable (each passkey is cryptographically bound)
// Charter P3: Explicit state via isRevoked flag
model PasskeyCredential {
  id            String    @id @default(uuid()) @db.Uuid
  userAccountId String    @db.Uuid
  // WebAuthn credential ID (base64url encoded, unique per authenticator)
  credentialId  String    @unique
  // COSE public key (base64url encoded)
  publicKey     String
  // Signature counter for replay protection
  counter       BigInt    @default(0)
  // Optional transports hint (e.g., ["usb", "nfc", "ble", "internal"])
  transports    String[]
  // User-friendly device name (e.g., "iPhone 15", "YubiKey 5")
  deviceName    String?
  // AAGUID of the authenticator (for device type identification)
  aaguid        String?
  // Revocation and lifecycle tracking
  isRevoked     Boolean   @default(false)
  revokedAt     DateTime?
  revokedById   String?   @db.Uuid
  revokedReason String?
  lastUsedAt    DateTime?
  createdAt     DateTime  @default(now())

  userAccount UserAccount @relation(fields: [userAccountId], references: [id], onDelete: Cascade)
  revokedBy   Member?     @relation("PasskeyRevokedBy", fields: [revokedById], references: [id], onDelete: SetNull)

  @@index([userAccountId])
  @@index([credentialId])
  @@index([isRevoked])
}

// AuthChallenge - Short-lived WebAuthn challenges
// These are used during registration and authentication ceremonies
// Charter N5: Challenges expire to prevent replay attacks
model AuthChallenge {
  id            String   @id @default(uuid()) @db.Uuid
  // The random challenge bytes (base64url encoded)
  challenge     String   @unique
  // Type: "registration" or "authentication"
  type          String
  // Associated user (null for unauthenticated login attempts)
  userAccountId String?  @db.Uuid
  // Associated email for login attempts (for rate limiting)
  email         String?
  // Client IP for rate limiting
  ipAddress     String?
  // Expiration (typically 5 minutes)
  expiresAt     DateTime
  // Whether this challenge has been used (prevent reuse)
  usedAt        DateTime?
  createdAt     DateTime @default(now())

  @@index([challenge])
  @@index([userAccountId])
  @@index([email])
  @@index([expiresAt])
}

// EmailMagicLink - Secure fallback authentication via email
// Charter: Ensures users can always regain access even if passkeys are lost
model EmailMagicLink {
  id            String    @id @default(uuid()) @db.Uuid
  // The secure token sent in the email (hashed for storage)
  tokenHash     String    @unique
  email         String
  // Associated user account (if exists)
  userAccountId String?   @db.Uuid
  // Purpose: "login" or "verify" (for email verification)
  purpose       String    @default("login")
  // Client IP that requested the link
  ipAddress     String?
  // Expiration (typically 15 minutes)
  expiresAt     DateTime
  // Usage tracking
  usedAt        DateTime?
  createdAt     DateTime  @default(now())

  @@index([tokenHash])
  @@index([email])
  @@index([expiresAt])
}

// Session - DB-backed server-side sessions for authentication
// Charter P1: Identity provable via server-validated session tokens
// Charter P3: Explicit state via revokedAt for session invalidation
model Session {
  id            String    @id @default(uuid()) @db.Uuid
  // Token hash stored (never store raw tokens)
  // Format: "salt:hash" where salt is per-token and hash is scrypt output
  tokenHash     String    @unique
  // Associated user account
  userAccountId String    @db.Uuid
  // Session metadata for security tracking
  email         String
  globalRole    String
  // Client info for security audit
  ipAddress     String?
  userAgent     String?
  // Session lifecycle
  expiresAt     DateTime
  lastActivityAt DateTime @default(now())
  createdAt     DateTime  @default(now())
  // Revocation support (P3: explicit state machine)
  revokedAt     DateTime?
  revokedById   String?   @db.Uuid
  revokedReason String?

  // Impersonation support (admin viewing as another member)
  // When set, the admin is viewing the app as this member for support/debugging
  // Charter P1: Both real admin and impersonated member tracked
  // Charter P7: Audit log entries created for start/end
  impersonatingMemberId String?   @db.Uuid
  impersonatedAt        DateTime? // When impersonation started

  userAccount UserAccount @relation(fields: [userAccountId], references: [id], onDelete: Cascade)
  revokedBy   Member?     @relation("SessionRevokedBy", fields: [revokedById], references: [id], onDelete: SetNull)
  impersonatingMember Member? @relation("SessionImpersonating", fields: [impersonatingMemberId], references: [id], onDelete: SetNull)

  @@index([tokenHash])
  @@index([userAccountId])
  @@index([expiresAt])
  @@index([revokedAt])
}

model Event {
  id          String    @id @default(uuid()) @db.Uuid
  title       String
  description String?
  category    String?
  location    String?
  startTime   DateTime
  endTime     DateTime?
  // DEPRECATED: Use ticketTiers for capacity. Kept for migration compatibility.
  capacity    Int?
  // DEPRECATED: Use status field. Kept for migration compatibility.
  isPublished Boolean     @default(false)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Event lifecycle (Charter P3: state machine over booleans)
  status               EventStatus @default(DRAFT)
  publishAt            DateTime?   // When to auto-publish (null = manual)
  registrationDeadline DateTime?   // When registration closes (null = at startTime)

  // Registration scheduling (SBNC policy: Sunday announce, Tuesday open)
  requiresRegistration Boolean   @default(true) // Events with tickets/capacity require registration
  registrationOpensAt  DateTime? // When registration UI becomes active (null = immediate when published)

  // eNews integration for VP Communications
  enewsBlurbDraft String? // Short blurb for weekly newsletter (VP Comms editable)

  // Approval workflow
  submittedAt    DateTime? // When submitted for review
  submittedById  String?   @db.Uuid
  approvedAt     DateTime? // When approved by VP Activities
  approvedById   String?   @db.Uuid
  approvalNotes  String?   // Notes from approver

  // Publication tracking
  publishedAt   DateTime? // When made visible to members
  publishedById String?   @db.Uuid

  // Changes requested tracking
  changesRequestedAt   DateTime? // When VP returned for revisions
  changesRequestedById String?   @db.Uuid
  rejectionNotes       String?   // Reason for requesting changes

  // Cancellation tracking
  canceledAt     DateTime? // When event was canceled
  canceledById   String?   @db.Uuid
  canceledReason String?   // Reason for cancellation

  // Committee ownership (for RBAC filtering)
  committeeId String? @db.Uuid

  ticketTiers    TicketTier[]
  registrations  EventRegistration[]
  photoAlbum     PhotoAlbum?
  eventChairId   String?                @db.Uuid
  eventChair     Member?                @relation(fields: [eventChairId], references: [id], onDelete: SetNull)
  serviceHistory MemberServiceHistory[]
  postmortem     EventPostmortem?
  notes          EventNote[]

  // Approval workflow relations
  submittedBy        Member? @relation("EventSubmittedBy", fields: [submittedById], references: [id], onDelete: SetNull)
  approvedBy         Member? @relation("EventApprovedBy", fields: [approvedById], references: [id], onDelete: SetNull)
  publishedBy        Member? @relation("EventPublishedBy", fields: [publishedById], references: [id], onDelete: SetNull)
  changesRequestedBy Member? @relation("EventChangesRequestedBy", fields: [changesRequestedById], references: [id], onDelete: SetNull)
  canceledBy         Member? @relation("EventCanceledBy", fields: [canceledById], references: [id], onDelete: SetNull)
  committee          Committee? @relation(fields: [committeeId], references: [id], onDelete: SetNull)

  // Clone tracking - for safe event cloning workflow
  // Charter P6: Cloned events start as drafts requiring explicit approval
  // Charter P3: Explicit state - clonedFromId marks inherited structure vs original content
  clonedFromId String?   @db.Uuid
  clonedAt     DateTime?
  clonedFrom   Event?    @relation("EventClones", fields: [clonedFromId], references: [id], onDelete: SetNull)
  clones       Event[]   @relation("EventClones")

  // Support case relations
  supportCases SupportCase[]

  @@index([eventChairId])
  @@index([startTime])
  @@index([category])
  @@index([clonedFromId])
  @@index([status])
  @@index([committeeId])
  @@index([submittedById])
  @@index([approvedById])
  @@index([publishedById])
  @@index([changesRequestedById])
  @@index([canceledById])
}

// EventPostmortem - Chair Notebook for institutional knowledge
// Charter P7: Audit logging - tracks who created/approved postmortems
// Applied ONLY to completed or cancelled events
model EventPostmortem {
  id        String   @id @default(uuid()) @db.Uuid
  eventId   String   @unique @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Preparation notes
  setupNotes    String? // What had to be done before the event
  contactsUsed  String? // Freeform list of vendors, contacts, etc.
  timelineNotes String? // How the day/preparation unfolded

  // Success ratings (1-5 scale, null = not rated)
  attendanceRating   Int? // 1-5: How well attended?
  logisticsRating    Int? // 1-5: How smooth was logistics?
  satisfactionRating Int? // 1-5: Perceived member satisfaction

  // Retrospective notes
  whatWorked           String? // Things that went well
  whatDidNot           String? // Things that didn't work
  whatToChangeNextTime String? // Recommendations for future chairs

  // Access control
  internalOnly Boolean @default(true) // If true, only visible to officers/chairs

  // Approval workflow
  status     PostmortemStatus @default(DRAFT)
  approvedAt DateTime?
  approvedBy String?          @db.Uuid

  // Relations
  event    Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  approver Member? @relation("PostmortemApprover", fields: [approvedBy], references: [id], onDelete: SetNull)

  // Who created the postmortem
  createdById String? @db.Uuid
  createdBy   Member? @relation("PostmortemCreator", fields: [createdById], references: [id], onDelete: SetNull)

  // Author contact snapshot (captured at submission for institutional memory)
  submittedAt     DateTime? // When the postmortem was submitted for review
  submittedByName String?   // Chair's full name at submission
  submittedByEmail String?  // Chair's email at submission
  submittedByPhone String?  // Chair's phone at submission

  @@index([eventId])
  @@index([status])
  @@index([createdById])
}

enum PostmortemStatus {
  DRAFT      // Being edited by chair
  SUBMITTED  // Ready for VP review
  APPROVED   // Locked, VP approved
  UNLOCKED   // VP unlocked for further edits
}

// EventNote - Chair notebook entries for institutional memory
// Charter P7: Audit logged via author tracking
// Supports planning notes, venue info, lessons learned
model EventNote {
  id        String        @id @default(uuid()) @db.Uuid
  eventId   String        @db.Uuid
  authorId  String        @db.Uuid
  noteType  EventNoteType
  content   String        // Markdown supported
  isPrivate Boolean       @default(false) // If true, only chair/admins can see
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  event  Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  author Member @relation("EventNoteAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@index([eventId, noteType])
  @@index([authorId])
}

// TicketTier - Defines registration tiers with capacity and pricing
// Charter P3: Explicit state for registration availability
// Capacity is derived from sum of tier quantities, not a single field
model TicketTier {
  id           String   @id @default(uuid()) @db.Uuid
  eventId      String   @db.Uuid
  name         String // e.g., "Member", "Guest", "Early Bird"
  description  String?
  priceCents   Int      @default(0) // 0 = free tier
  quantity     Int // Available spots for this tier
  sortOrder    Int      @default(0) // Display order
  isActive     Boolean  @default(true)
  salesStartAt DateTime? // When this tier becomes available (null = immediately)
  salesEndAt   DateTime? // When this tier closes (null = at event start)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  event         Event               @relation(fields: [eventId], references: [id], onDelete: Cascade)
  registrations EventRegistration[]

  @@index([eventId])
  @@index([eventId, isActive])
}

model EventRegistration {
  id               String             @id @default(uuid()) @db.Uuid
  eventId          String             @db.Uuid
  memberId         String             @db.Uuid
  ticketTierId     String?            @db.Uuid // Which tier they registered for (null for legacy)
  status           RegistrationStatus @default(DRAFT)
  waitlistPosition Int?
  registeredAt     DateTime
  cancelledAt      DateTime?
  confirmedAt      DateTime? // When payment completed or free event confirmed
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt

  event          Event           @relation(fields: [eventId], references: [id])
  member         Member          @relation(fields: [memberId], references: [id])
  ticketTier     TicketTier?     @relation(fields: [ticketTierId], references: [id])
  paymentIntents PaymentIntent[]

  @@unique([eventId, memberId])
  @@index([eventId])
  @@index([memberId])
  @@index([ticketTierId])
  @@index([eventId, status, waitlistPosition])
  @@index([memberId, eventId])
}

// PaymentIntent - Tracks payment attempts with idempotency
// Charter N5: Automation must be idempotent
// Charter P3: Explicit state machine for payment lifecycle
model PaymentIntent {
  id                String              @id @default(uuid()) @db.Uuid
  registrationId    String              @db.Uuid
  idempotencyKey    String              @unique // Client-provided key to prevent duplicates
  providerRef       String? // External payment provider reference
  provider          String              @default("fake") // "fake", "stripe", etc.
  status            PaymentIntentStatus @default(CREATED)
  amountCents       Int // Amount in cents
  currency          String              @default("USD")
  description       String?
  metadata          Json?
  checkoutUrl       String? // Redirect URL for hosted checkout
  webhookReceivedAt DateTime? // When we received completion webhook
  failureReason     String?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  registration EventRegistration @relation(fields: [registrationId], references: [id], onDelete: Cascade)

  @@index([registrationId])
  @@index([providerRef])
  @@index([status])
  @@index([createdAt])
}

// ============================================================================
// PAYMENT METHODS - Saved payment methods for members
// Charter P3: Explicit state machine for payment method lifecycle
// Charter P7: Audit logged via AuditLog
// ============================================================================

enum PaymentMethodType {
  CARD // Credit/debit card (existing flow)
  ACH  // Bank transfer (ACH)
}

enum PaymentMethodStatus {
  ACTIVE  // Can be used for payments
  REVOKED // No longer usable
}

// PaymentMethod - Saved payment method for a member
// Does NOT store actual bank/card numbers - only tokens/display info
model PaymentMethod {
  id          String              @id @default(uuid()) @db.Uuid
  memberId    String              @db.Uuid
  type        PaymentMethodType
  status      PaymentMethodStatus @default(ACTIVE)
  displayName String              // e.g., "ACH ending in 1234" or "Visa ending in 4242"
  provider    String              // e.g., "DEMO_ACH", "stripe"
  providerRef String              // Opaque token from provider (NOT bank/card number)
  isDefault   Boolean             @default(false)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  revokedAt   DateTime?

  member Member @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@index([memberId])
  @@index([memberId, status])
  @@index([memberId, type, status])
}

model Photo {
  id         String    @id @default(uuid()) @db.Uuid
  albumId    String    @db.Uuid
  uploaderId String    @db.Uuid
  filename   String
  url        String
  caption    String?
  takenAt    DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  album         PhotoAlbum  @relation(fields: [albumId], references: [id])
  uploader      Member      @relation(fields: [uploaderId], references: [id])
  coverForAlbum PhotoAlbum? @relation("CoverPhoto")

  @@index([albumId])
  @@index([uploaderId])
}

model PhotoAlbum {
  id           String   @id @default(uuid()) @db.Uuid
  eventId      String?  @unique @db.Uuid
  title        String
  description  String?
  coverPhotoId String?  @unique @db.Uuid
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  event      Event?  @relation(fields: [eventId], references: [id])
  photos     Photo[]
  coverPhoto Photo?  @relation("CoverPhoto", fields: [coverPhotoId], references: [id])
}

model EmailLog {
  id             String      @id @default(uuid()) @db.Uuid
  memberId       String?     @db.Uuid
  recipientEmail String
  subject        String
  bodyPreview    String?
  sentAt         DateTime
  channel        String
  templateKey    String?
  status         EmailStatus @default(QUEUED)
  createdAt      DateTime    @default(now())

  member Member? @relation(fields: [memberId], references: [id])

  @@index([memberId])
  @@index([sentAt])
  @@index([status])
}

// ============================================================================
// PUBLISHING AND COMMUNICATIONS SYSTEM
// Copyright (c) Santa Barbara Newcomers Club
// ============================================================================

// Enums for Publishing System

enum PageStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum PageVisibility {
  PUBLIC
  MEMBERS_ONLY
  ROLE_RESTRICTED
}

enum ThemeStatus {
  DRAFT
  ACTIVE
  ARCHIVED
}

enum TemplateType {
  PAGE
  EMAIL
}

enum CampaignStatus {
  DRAFT
  SCHEDULED
  SENDING
  SENT
  CANCELLED
}

enum DeliveryStatus {
  PENDING
  SENT
  DELIVERED
  BOUNCED
  FAILED
  COMPLAINED
  UNSUBSCRIBED
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  PUBLISH
  UNPUBLISH
  SEND
  ARCHIVE
  EMAIL_SENT
  EMAIL_BOUNCED
  EMAIL_COMPLAINED
  EMAIL_UNSUBSCRIBED
  // Passkey/WebAuthn security events
  PASSKEY_REGISTERED
  PASSKEY_USED
  PASSKEY_REVOKED
  PASSKEY_LOGIN_FAILED
  EMAIL_LINK_SENT
  EMAIL_LINK_USED
  // Magic link / session auth events
  LOGIN
  LOGOUT
  SESSION_REVOKED
  // Impersonation events
  IMPERSONATION_START
  IMPERSONATION_END
  // Event registration events
  EVENT_REGISTER
  EVENT_WAITLIST_JOIN
  EVENT_CANCEL_REGISTRATION
  // Payment method events
  PAYMENT_METHOD_ADDED
  PAYMENT_METHOD_REVOKED
}

// Theme - Visual styling tokens and CSS
model Theme {
  id          String      @id @default(uuid()) @db.Uuid
  name        String
  slug        String      @unique
  description String?
  status      ThemeStatus @default(DRAFT)
  tokens      Json // Design tokens: colors, fonts, spacing
  cssText     String?     @db.Text // Custom CSS overrides
  cssUrl      String? // External CSS URL (optional)
  isDefault   Boolean     @default(false)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  pages Page[]

  @@index([status])
  @@index([isDefault])
}

// Template - Reusable content structures for pages and emails
model Template {
  id            String       @id @default(uuid()) @db.Uuid
  name          String
  slug          String       @unique
  type          TemplateType
  description   String?
  schemaVersion Int          @default(1)
  content       Json // Block schema definition
  themeId       String?      @db.Uuid
  isActive      Boolean      @default(true)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  pages            Page[]
  messageTemplates MessageTemplate[]

  @@index([type])
  @@index([isActive])
}

// Page - Published content pages
model Page {
  id             String         @id @default(uuid()) @db.Uuid
  slug           String         @unique
  title          String
  description    String? // SEO meta description
  status         PageStatus     @default(DRAFT)
  visibility     PageVisibility @default(PUBLIC)
  templateId     String?        @db.Uuid
  themeId        String?        @db.Uuid
  content        Json // Block content data
  seoTitle       String? // Override for SEO
  seoDescription String? // Override for SEO
  seoImage       String? // Social sharing image
  publishAt      DateTime? // Scheduled publish time
  publishedAt    DateTime? // When actually published
  audienceRuleId String?        @db.Uuid
  createdById    String?        @db.Uuid
  updatedById    String?        @db.Uuid
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  template     Template?     @relation(fields: [templateId], references: [id])
  theme        Theme?        @relation(fields: [themeId], references: [id])
  audienceRule AudienceRule? @relation(fields: [audienceRuleId], references: [id])
  createdBy    Member?       @relation("PageCreatedBy", fields: [createdById], references: [id])
  updatedBy    Member?       @relation("PageUpdatedBy", fields: [updatedById], references: [id])

  @@index([status])
  @@index([visibility])
  @@index([publishAt])
  @@index([templateId])
}

// Navigation - Site navigation menus
model Navigation {
  id             String   @id @default(uuid()) @db.Uuid
  name           String
  slug           String   @unique
  items          Json // Ordered navigation items with labels, hrefs, children
  audienceRuleId String?  @db.Uuid
  sortOrder      Int      @default(0)
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  audienceRule AudienceRule? @relation(fields: [audienceRuleId], references: [id])

  @@index([isActive])
  @@index([sortOrder])
}

// Asset - Uploaded files and media
model Asset {
  id        String   @id @default(uuid()) @db.Uuid
  type      String // image, document, video, etc.
  filename  String
  url       String
  mimeType  String?
  size      Int? // File size in bytes
  width     Int? // Image width
  height    Int? // Image height
  alt       String? // Alt text for images
  metadata  Json? // Additional metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
}

// AudienceRule - Who can see content
model AudienceRule {
  id          String   @id @default(uuid()) @db.Uuid
  name        String
  description String?
  rules       Json // Query rules: roles, groups, membershipStatuses, memberIds, isPublic
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  pages            Page[]
  navigations      Navigation[]
  mailingLists     MailingList[]
  messageCampaigns MessageCampaign[]

  @@index([name])
}

// Permission - Fine-grained permissions for resources
model Permission {
  id           String   @id @default(uuid()) @db.Uuid
  resourceType String // page, template, theme, mailing_list, etc.
  resourceId   String   @db.Uuid
  memberId     String?  @db.Uuid
  roleSlug     String? // Committee role slug for role-based permissions
  action       String // view, edit, publish, delete, send
  createdAt    DateTime @default(now())

  member Member? @relation(fields: [memberId], references: [id])

  @@unique([resourceType, resourceId, memberId, action])
  @@index([resourceType, resourceId])
  @@index([memberId])
  @@index([roleSlug])
}

// MailingList - Email recipient lists
model MailingList {
  id             String   @id @default(uuid()) @db.Uuid
  name           String
  slug           String   @unique
  description    String?
  audienceRuleId String?  @db.Uuid
  staticMembers  Json? // Array of member IDs for static lists
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  audienceRule     AudienceRule?     @relation(fields: [audienceRuleId], references: [id])
  messageCampaigns MessageCampaign[]

  @@index([isActive])
}

// MessageTemplate - Email/SMS templates with token replacement
model MessageTemplate {
  id           String   @id @default(uuid()) @db.Uuid
  name         String
  slug         String   @unique
  subject      String // Supports tokens like {{member.firstName}}
  bodyHtml     String   @db.Text
  bodyText     String?  @db.Text
  tokens       Json? // Available token definitions
  templateId   String?  @db.Uuid // Optional layout template
  providerOpts Json? // Provider-specific options
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  template         Template?         @relation(fields: [templateId], references: [id])
  messageCampaigns MessageCampaign[]

  @@index([isActive])
}

// MessageCampaign - Email campaigns
model MessageCampaign {
  id                String         @id @default(uuid()) @db.Uuid
  name              String
  messageTemplateId String         @db.Uuid
  mailingListId     String?        @db.Uuid
  audienceRuleId    String?        @db.Uuid // Alternative to mailing list
  status            CampaignStatus @default(DRAFT)
  scheduledAt       DateTime?
  sentAt            DateTime?
  totalRecipients   Int?
  successCount      Int?
  failureCount      Int?
  createdById       String?        @db.Uuid
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  messageTemplate MessageTemplate @relation(fields: [messageTemplateId], references: [id])
  mailingList     MailingList?    @relation(fields: [mailingListId], references: [id])
  audienceRule    AudienceRule?   @relation(fields: [audienceRuleId], references: [id])
  createdBy       Member?         @relation(fields: [createdById], references: [id])
  deliveryLogs    DeliveryLog[]

  @@index([status])
  @@index([scheduledAt])
  @@index([messageTemplateId])
  @@index([mailingListId])
}

// DeliveryLog - Individual message delivery tracking
model DeliveryLog {
  id             String         @id @default(uuid()) @db.Uuid
  campaignId     String         @db.Uuid
  recipientId    String?        @db.Uuid
  recipientEmail String
  status         DeliveryStatus @default(PENDING)
  providerMsgId  String?
  sentAt         DateTime?
  deliveredAt    DateTime?
  bouncedAt      DateTime?
  bounceType     String? // hard, soft, undetermined
  bounceReason   String?
  complainedAt   DateTime?
  unsubscribedAt DateTime?
  openedAt       DateTime?
  clickedAt      DateTime?
  createdAt      DateTime       @default(now())

  campaign  MessageCampaign @relation(fields: [campaignId], references: [id])
  recipient Member?         @relation(fields: [recipientId], references: [id])

  @@index([campaignId])
  @@index([recipientId])
  @@index([status])
  @@index([recipientEmail])
}

// AuditLog - Track all privileged actions
model AuditLog {
  id           String      @id @default(uuid()) @db.Uuid
  action       AuditAction
  resourceType String // page, template, theme, campaign, etc.
  resourceId   String      @db.Uuid
  memberId     String?     @db.Uuid
  before       Json? // State before change
  after        Json? // State after change
  metadata     Json? // Additional context
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime    @default(now())

  member Member? @relation(fields: [memberId], references: [id])

  @@index([resourceType, resourceId])
  @@index([memberId])
  @@index([action])
  @@index([createdAt])
}

// JobRun - Track cron job executions for idempotency and observability
model JobRun {
  id           String       @id @default(uuid()) @db.Uuid
  jobName      String // Identifier for the job (e.g., "transitions", "cleanup")
  scheduledFor DateTime     @db.Date // Date the job was scheduled for (for idempotency)
  requestId    String? // Request ID for tracing
  status       JobRunStatus @default(PENDING)
  startedAt    DateTime?
  finishedAt   DateTime?
  errorSummary String?      @db.Text // Error message if failed
  metadata     Json? // Additional job-specific data
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  // UNIQUE constraint ensures idempotency - only one run per job per day
  @@unique([jobName, scheduledFor])
  @@index([jobName])
  @@index([status])
  @@index([scheduledFor])
  @@index([createdAt])
}

// ============================================================================
// EMAIL TRACKING CONFIGURATION
// ============================================================================

// EmailTrackingConfig - Global settings for email tracking behavior
// Privacy-conscious: open/click tracking OFF by default (Charter P6)
model EmailTrackingConfig {
  id                     String   @id @default(uuid()) @db.Uuid
  trackOpens             Boolean  @default(false) // Disabled by default for privacy
  trackClicks            Boolean  @default(false) // Disabled by default for privacy
  trackBounces           Boolean  @default(true) // Essential for deliverability
  trackComplaints        Boolean  @default(true) // Essential for compliance
  autoSuppressHardBounce Boolean  @default(true) // Auto-suppress hard bounced addresses
  autoSuppressComplaint  Boolean  @default(true) // Auto-suppress complaint addresses
  retentionDays          Int      @default(90) // Days to keep delivery logs
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
}

// EmailSuppressionList - Emails that should not receive messages
// Tracks hard bounces, complaints, and manual suppressions
model EmailSuppressionList {
  id          String    @id @default(uuid()) @db.Uuid
  email       String    @unique
  reason      String // hard_bounce, complaint, manual, unsubscribe
  sourceLogId String?   @db.Uuid // DeliveryLog that caused suppression
  expiresAt   DateTime? // Optional expiration for temporary suppressions
  addedAt     DateTime  @default(now())
  createdAt   DateTime  @default(now())

  @@index([email])
  @@index([reason])
  @@index([expiresAt])
}

// ============================================================================
// SECURE FILE STORAGE SYSTEM
// File metadata, access control, and tagging
// Copyright (c) Santa Barbara Newcomers Club
//
// Charter Principles:
// - P1: Identity provable (uploadedBy on all files)
// - P2: Default deny, least privilege (FileAccess permissions)
// - P7: Full audit trail
// - P9: Fail closed (no access without explicit grant)
// ============================================================================

// Principal type for file access permissions
// User = individual member, Role = global role, Group = custom group
enum FilePrincipalType {
  USER
  ROLE
  GROUP
}

// Permission level for file access
enum FilePermission {
  READ // Can view/download file
  WRITE // Can update metadata
  ADMIN // Can manage permissions, delete file
}

// FileObject - Metadata for stored files
model FileObject {
  id          String   @id @default(uuid()) @db.Uuid
  name        String // Original filename
  mimeType    String // MIME type (e.g., "application/pdf")
  size        Int // File size in bytes
  checksum    String // SHA-256 hash for integrity verification
  storageKey  String   @unique // Key/path in storage backend
  description String? // Optional description
  isPublic    Boolean  @default(false) // If true, accessible without auth
  uploadedById String  @db.Uuid
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  uploadedBy Member       @relation("FileUploadedBy", fields: [uploadedById], references: [id])
  accessList FileAccess[]
  tags       FileTag[]

  @@index([uploadedById])
  @@index([mimeType])
  @@index([createdAt])
  @@index([isPublic])
}

// FileAccess - Access control entries for files
// Charter P2: Each permission is an explicit grant
model FileAccess {
  id            String            @id @default(uuid()) @db.Uuid
  fileId        String            @db.Uuid
  principalType FilePrincipalType
  principalId   String // Member UUID (User), role slug (Role), or group ID (Group)
  permission    FilePermission
  grantedById   String?           @db.Uuid
  expiresAt     DateTime? // Optional expiration
  createdAt     DateTime          @default(now())

  file      FileObject @relation(fields: [fileId], references: [id], onDelete: Cascade)
  grantedBy Member?    @relation("FileAccessGrantedBy", fields: [grantedById], references: [id])

  @@unique([fileId, principalType, principalId, permission])
  @@index([fileId])
  @@index([principalType, principalId])
  @@index([expiresAt])
}

// FileTag - Categorization tags for files
model FileTag {
  id        String   @id @default(uuid()) @db.Uuid
  fileId    String   @db.Uuid
  tag       String // Tag name (e.g., "governance", "minutes", "policy")
  createdAt DateTime @default(now())

  file FileObject @relation(fields: [fileId], references: [id], onDelete: Cascade)

  @@unique([fileId, tag])
  @@index([tag])
  @@index([fileId])
}

// ============================================================================
// GOVERNANCE SYSTEM
// Board meetings, minutes, motions, annotations, and review flags
// Copyright (c) Santa Barbara Newcomers Club
//
// Charter Principles:
// - P1: Identity provable (createdBy on all records)
// - P3: Explicit state machine for minutes workflow
// - P5: Published minutes immutable (versioning)
// - P7: Full audit trail
// ============================================================================

// GovernanceMeeting - Board/Executive meeting records
model GovernanceMeeting {
  id              String                @id @default(uuid()) @db.Uuid
  date            DateTime              @db.Date
  type            GovernanceMeetingType
  title           String? // Optional descriptive title
  location        String? // Meeting location or "Virtual"
  attendanceCount Int? // Number of attendees
  quorumMet       Boolean               @default(true)
  createdById     String?               @db.Uuid
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt

  createdBy Member?             @relation("MeetingCreatedBy", fields: [createdById], references: [id])
  minutes   GovernanceMinutes[]
  motions   GovernanceMotion[]

  @@unique([date, type])
  @@index([date])
  @@index([type])
  @@index([createdById])
}

// GovernanceMinutes - Meeting minutes with version control
// Immutability: Once PUBLISHED, content is immutable. New versions create new rows.
model GovernanceMinutes {
  id             String        @id @default(uuid()) @db.Uuid
  meetingId      String        @db.Uuid
  status         MinutesStatus @default(DRAFT)
  version        Int           @default(1)
  content        Json // Structured content (markdown or block-based)
  summary        String?       @db.Text // Executive summary
  // Workflow tracking
  submittedAt    DateTime? // When Secretary submitted for review
  submittedById  String?       @db.Uuid
  reviewedAt     DateTime? // When President reviewed
  reviewedById   String?       @db.Uuid
  reviewNotes    String? // President's notes on revision request
  approvedAt     DateTime? // When President approved
  approvedById   String?       @db.Uuid
  publishedAt    DateTime? // When Secretary published
  publishedById  String?       @db.Uuid
  // Standard timestamps
  createdById    String?       @db.Uuid
  lastEditedById String?       @db.Uuid
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  meeting      GovernanceMeeting @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  createdBy    Member?           @relation("MinutesCreatedBy", fields: [createdById], references: [id])
  lastEditedBy Member?           @relation("MinutesLastEditedBy", fields: [lastEditedById], references: [id])
  submittedBy  Member?           @relation("MinutesSubmittedBy", fields: [submittedById], references: [id])
  reviewedBy   Member?           @relation("MinutesReviewedBy", fields: [reviewedById], references: [id])
  approvedBy   Member?           @relation("MinutesApprovedBy", fields: [approvedById], references: [id])
  publishedBy  Member?           @relation("MinutesPublishedBy", fields: [publishedById], references: [id])

  @@unique([meetingId, version])
  @@index([meetingId])
  @@index([status])
  @@index([createdAt])
}

// GovernanceMotion - Motions and voting records
model GovernanceMotion {
  id           String        @id @default(uuid()) @db.Uuid
  meetingId    String        @db.Uuid
  motionNumber Int // Sequential number within meeting (e.g., Motion 1, Motion 2)
  motionText   String        @db.Text
  movedById    String?       @db.Uuid
  secondedById String?       @db.Uuid
  // Vote tallies
  votesYes     Int           @default(0)
  votesNo      Int           @default(0)
  votesAbstain Int           @default(0)
  result       MotionResult?
  resultNotes  String? // Notes about the result (e.g., "Tabled for further review")
  // Timestamps
  createdById  String?       @db.Uuid
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  meeting     GovernanceMeeting      @relation(fields: [meetingId], references: [id], onDelete: Cascade)
  movedBy     Member?                @relation("MotionMovedBy", fields: [movedById], references: [id])
  secondedBy  Member?                @relation("MotionSecondedBy", fields: [secondedById], references: [id])
  createdBy   Member?                @relation("MotionCreatedBy", fields: [createdById], references: [id])
  annotations GovernanceAnnotation[]

  @@unique([meetingId, motionNumber])
  @@index([meetingId])
  @@index([result])
}

// GovernanceAnnotation - Annotations on governance documents
// Can annotate: motions, bylaws sections, policy docs, pages
model GovernanceAnnotation {
  id          String   @id @default(uuid()) @db.Uuid
  targetType  String // "motion", "bylaw", "policy", "page", "file"
  targetId    String   @db.Uuid // ID of the target resource
  motionId    String?  @db.Uuid // Direct relation if targeting a motion
  anchor      String? // Anchor/location within the target (e.g., section ID, paragraph)
  body        String   @db.Text // Annotation content (markdown)
  isPublished Boolean  @default(false) // Whether visible to non-governance users
  createdById String?  @db.Uuid
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  motion    GovernanceMotion? @relation(fields: [motionId], references: [id], onDelete: Cascade)
  createdBy Member?           @relation("AnnotationCreatedBy", fields: [createdById], references: [id])

  @@index([targetType, targetId])
  @@index([motionId])
  @@index([createdById])
  @@index([isPublished])
}

// GovernanceReviewFlag - Flags for review (e.g., "Review for Insurance")
// Can flag: pages, files, policies, events
model GovernanceReviewFlag {
  id           String           @id @default(uuid()) @db.Uuid
  targetType   String // "page", "file", "policy", "event", "bylaw"
  targetId     String           @db.Uuid // ID of the target resource
  flagType     ReviewFlagType
  status       ReviewFlagStatus @default(OPEN)
  title        String // Brief description of concern
  notes        String?          @db.Text // Detailed notes
  dueDate      DateTime? // Optional deadline for resolution
  // Resolution tracking
  resolvedAt   DateTime?
  resolvedById String?          @db.Uuid
  resolution   String?          @db.Text // How it was resolved
  // Standard timestamps
  createdById  String?          @db.Uuid
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  createdBy  Member? @relation("FlagCreatedBy", fields: [createdById], references: [id])
  resolvedBy Member? @relation("FlagResolvedBy", fields: [resolvedById], references: [id])

  @@index([targetType, targetId])
  @@index([flagType])
  @@index([status])
  @@index([dueDate])
  @@index([createdById])
}

// ============================================================================
// WILD APRICOT IMPORT SYSTEM
// ID mapping and sync state tracking for WA data import
// Copyright (c) Santa Barbara Newcomers Club
//
// Charter Principles:
// - P1: Identity provable (sync actor in audit logs)
// - N5: Idempotent automation (upserts, not inserts)
// - P7: Full audit trail
// ============================================================================

// WaIdMapping - Maps Wild Apricot integer IDs to ClubOS UUIDs
// Essential for idempotent upserts and foreign key resolution
model WaIdMapping {
  id         String   @id @default(uuid()) @db.Uuid
  entityType String   // "Member", "Event", "EventRegistration"
  waId       Int      // Wild Apricot integer ID
  clubosId   String   @db.Uuid // ClubOS entity UUID
  syncedAt   DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([entityType, waId])
  @@index([entityType, clubosId])
  @@index([syncedAt])
}

// WaSyncState - Tracks sync progress for incremental syncs
model WaSyncState {
  id              String    @id @default(uuid()) @db.Uuid
  lastFullSync    DateTime?
  lastIncSync     DateTime?
  lastContactSync DateTime?
  lastEventSync   DateTime?
  lastRegSync     DateTime?
  metadata        Json?     // Additional sync state
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

// ============================================================================
// SUPPORT CASE TRACKING
// Tech Lead support intake workflow (see docs/operations/TECH_LEAD_SUPPORT_GUIDE.md)
// Charter P7: Observability - track all support requests to closure
// ============================================================================

// SupportCase - Tracks support requests from intake to closure
model SupportCase {
  id                String                 @id @default(uuid()) @db.Uuid
  caseNumber        Int                    @unique @default(autoincrement())

  // Submitter info
  submitterName     String                 // Name of person who reported
  submitterEmail    String?                // Contact email if available
  submitterId       String?                @db.Uuid // Link to Member if known
  submitter         Member?                @relation(fields: [submitterId], references: [id])

  // Request details
  channel           SupportCaseChannel     // How request came in
  receivedAt        DateTime               @default(now())
  description       String                 // Verbatim original request
  context           Json?                  // Additional structured context (page, role, device, etc.)

  // Classification
  status            SupportCaseStatus      @default(OPEN)
  category          SupportCaseCategory    @default(UNKNOWN)
  initialCategory   SupportCaseCategory?   // AI-suggested category at intake

  // Owner
  ownerId           String?                @db.Uuid
  owner             Member?                @relation("CaseOwner", fields: [ownerId], references: [id])

  // Resolution
  resolution        SupportCaseResolution?
  resolutionNotes   String?                // What was done
  preventiveAction  String?                // System improvement made (if any)

  // Linked artifacts
  relatedEventId    String?                @db.Uuid // If related to specific event
  relatedEvent      Event?                 @relation(fields: [relatedEventId], references: [id])
  relatedMemberId   String?                @db.Uuid // If related to specific member
  relatedMember     Member?                @relation("RelatedCases", fields: [relatedMemberId], references: [id])
  linkedPR          String?                // GitHub PR if code fix
  linkedDocs        String?                // Doc pages updated

  // AI analysis
  aiRootCause       String?                // AI-suggested root cause
  aiProposedActions Json?                  // AI-suggested action proposals
  aiRiskLevel       String?                // low, medium, high
  aiEffortLevel     String?                // trivial, small, medium, large

  // Timestamps
  closedAt          DateTime?
  closedById        String?                @db.Uuid
  closedBy          Member?                @relation("CaseCloser", fields: [closedById], references: [id])
  createdAt         DateTime               @default(now())
  updatedAt         DateTime               @updatedAt

  // Notes/updates
  notes             SupportCaseNote[]

  @@index([status])
  @@index([category])
  @@index([submitterId])
  @@index([ownerId])
  @@index([receivedAt])
  @@index([closedAt])
}

// SupportCaseNote - Timeline of updates on a case
model SupportCaseNote {
  id          String      @id @default(uuid()) @db.Uuid
  caseId      String      @db.Uuid
  case        SupportCase @relation(fields: [caseId], references: [id], onDelete: Cascade)

  authorId    String?     @db.Uuid
  author      Member?     @relation(fields: [authorId], references: [id])

  noteType    String      // "status_change", "clarification_sent", "response_sent", "internal", "ai_analysis"
  content     String      // The note content
  metadata    Json?       // Additional structured data (e.g., old/new status, email sent, etc.)

  createdAt   DateTime    @default(now())

  @@index([caseId])
  @@index([createdAt])
}
